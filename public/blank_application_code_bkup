**DO NOT DELETE

# Blank Application intresting things, not needed currently but may be needed for future reference.
Put with name of the file and line number(if possible)

app/models/feed_source.rb line 79

def rss_content2
	#return (FeedNormalizer::FeedNormalizer.parse open(self.url), :force_parser => FeedNormalizer::SimpleRssParser)
	return FeedParser.parse(open(self.url))
end

app/models/feed_source.rb line 107

def import_latest_items2
		feed = self.rss_content2
		feed.clean!
		feed.entries.each do |item|
			# Be sure that the item hasnt been imported before
			if self.feed_items.count(:conditions => { :link => item.url, :feed_source_id => self.id }) <= 0
				self.feed_items.create({
					:remote_id			=> item.id,
					:title					=> item.title,
					:description		=> item.description,
					:content				=> item.content,
					:authors				=> item.authors.join(' ,'),
					:date_published => item.date_published,
					:last_updated		=> item.last_updated,
					:categories			=> item.categories.join(' ,'),
					:link           => item.url,
					:copyright			=> item.copyright })
			end
	end
end

app/models/feed_item.rb line 35

def description=(value)
    # Remove html tags from description
    #value = strip_tags(value)

		# Clean first characters maching
		# Related Articles
		# (...)
		# Authors:  (...)
    #value.slice!(/\A[\n\t]*Related Articles.+Authors:[^\n]+\s+/m)

    # Remove last characters matching
    #   PMID: 123445
    #   [PubMed - as supplied by publisher]
    #value.slice!(/[\n\s]*PMID: \d+ \[PubMed - as supplied by publisher\][\n\s]*\Z/m)

    # After our cleaning, call the super method that will assignate the value
    super(value)
  end

app/models/image.rb

 file_column :file_path, :magick => { :versions => { :thumb => "100x100", :web => "500x500" } }


app/models/search.rb line 51

def conditions= params
		conditions = []
		params.each do |k, v|
			if !v.blank?
				conditions << "#{k} == #{(v.is_a?(Array) ? v.join(',') : v)}"
			end
		end
		self[:conditions] = conditions.join(' && ')
end

app/models/users line 141

def items
		@items = []
		ITEMS.map{ |item| item.pluralize }.each do |item|
			@items + self.send(item)
		end
		@items.sort { |a, b| a.created_at <=> b.created_at }
end

line 147

  def get_member_for_groups
      people = Person.find(:all, :conditions => ["user_id = ?",self.id])
      users = []
      Workspace.allowed_user_with_permission(self.id,'group_edit').each do |ws|
        users += ws.users.delete_if{ |e| !e.newsletter }
     end
     return (people + users.uniq).map{ |e| e.to_group_member }.sort!{ |a,b| a[:email].downcase <=> b[:email].downcase }
  end

app/controller/workspaces_controller.rb line 142

 def ajax_content
    params[:id] ||= params[:workspace_id]
    @current_object = Workspace.find(params[:id])
    params[:item_type] ||= get_allowed_item_types(current_workspace).first.to_s.pluralize
    @current_objects = get_items_list(params[:item_type], @current_object)
    @paginated_objects = @current_objects.paginate(:per_page => get_per_page_value, :page => params[:page])
    @i = 0
    render :partial => "items/items_list", :locals => { :ajax_url => ajax_items_path(params[:item_type]) }, :layout => false
    #render :text => display_item_in_list(@paginated_objects), :layout => false
  end

  def management
    @workspaces=Workspace.all
    respond_to do |format|
      format.html  { render :template => '/workspaces/management'}
    end

  end




